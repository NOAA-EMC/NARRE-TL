C$$$me  MAIN PROGRAM DOCUMENTATION BLOCK $$$$$$$$$$$$$$$$$$$$	C$$$me  MAIN PROGRAM DOCUMENTATION BLOCK $$$$$$$$$$$$$$$$$$$$
C								C
C MAIN PROGRAM: SREF_ENS_GEN					C MAIN PROGRAM: SREF_ENS_GEN
C   PRGMMR: DU               ORG: NP21        DATE: 2002-01-0	C   PRGMMR: DU               ORG: NP21        DATE: 2002-01-0
C								C
C ABSTRACT: READS IN SREF GRIB AND OUTPUTS ENSEMBLE GRIB 	C ABSTRACT: READS IN SREF GRIB AND OUTPUTS ENSEMBLE GRIB 
C           PRODUCTS. 						C           PRODUCTS. 
C								C
C PROGRAM HISTORY LOG:						C PROGRAM HISTORY LOG:
c								c
c Old Version:							c Old Version:
c 2001-07-10    Jun Du, initial program				c 2001-07-10    Jun Du, initial program
c								c
c Generic Version: 						c Generic Version: 
c								c
c 2005-08-01 Author: Binbin Zhou 				c 2005-08-01 Author: Binbin Zhou 
c								c
c       Re-organize the code structure and re-write the progr	c       Re-organize the code structure and re-write the progr
c								c
c        (1) The generic version dosn't fix GRIB# like 212 as	c        (1) The generic version dosn't fix GRIB# like 212 as
c            any GRIB#, and the domain (IM, JM) for the defin	c            any GRIB#, and the domain (IM, JM) for the defin
c            As long as GRIB# is specified in 'filename', thi	c            As long as GRIB# is specified in 'filename', thi
c            retrievs the domain (IM, JM, JF=IM*JM), then all	c            retrievs the domain (IM, JM, JF=IM*JM), then all
c            domain are dynamically allocated (on the fly)	c            domain are dynamically allocated (on the fly)
c        (2) Ensemble members (IENS) are not fixed, but depen	c        (2) Ensemble members (IENS) are not fixed, but depen
c            in which, the all of soft linked file name are l	c            in which, the all of soft linked file name are l
c            number of files are changeable, the program can 	c            number of files are changeable, the program can 
c        (3) The variables are changeable by using the 'varia	c        (3) The variables are changeable by using the 'varia
c            variables are defined: (i) direct variables: rea	c            variables are defined: (i) direct variables: rea
c            variables will also be computed for mean/spread 	c            variables will also be computed for mean/spread 
c            on the settings in each variable redcord (ii) de	c            on the settings in each variable redcord (ii) de
c            not read from GRIB files but need to do some der	c            not read from GRIB files but need to do some der
c        (4) Derived variables need some algorithm to derive,	c        (4) Derived variables need some algorithm to derive,
c            variables are defined in this program:		c            variables are defined in this program:
c            (A) Thickness of two (pressure) levels: mean/spr	c            (A) Thickness of two (pressure) levels: mean/spr
c            (B) 3hr, 6hr, 12hr, 24hr Accumulated precipitati	c            (B) 3hr, 6hr, 12hr, 24hr Accumulated precipitati
c            (C) 3hr, 6hr, 12hr, 24hr Accumulated snowfall: m	c            (C) 3hr, 6hr, 12hr, 24hr Accumulated snowfall: m
c            (D) Precipitation type: probability		c            (D) Precipitation type: probability
c            (E) Dominant precipitation: Mean			c            (E) Dominant precipitation: Mean
c            If want to process other derived product, user m	c            If want to process other derived product, user m
c            and then the computation code should be put into	c            and then the computation code should be put into
c        (5) User can request any kind of direct variables, e	c        (5) User can request any kind of direct variables, e
c            by editing the 'variable.tbl' file (read README 	c            by editing the 'variable.tbl' file (read README 
c 								c 
c change log:							c change log:
c 2006-01-12:Binbin Zhou					c 2006-01-12:Binbin Zhou
c             Add Geoff Manikin's algorithm to determine domi	c             Add Geoff Manikin's algorithm to determine domi
c 2006-03-01:Binbin Zhou					c 2006-03-01:Binbin Zhou
c             Modify wind spread computation by considering t	c             Modify wind spread computation by considering t
c             by Jun Du            				c             by Jun Du            
c 2006-03-30: Jun Du: convert the unit from K to C for lifted	c 2006-03-30: Jun Du: convert the unit from K to C for lifted
c								c
c 2006-04-30: Binbin Z. Add DTRA variance variables 		c 2006-04-30: Binbin Z. Add DTRA variance variables 
c								c
c 2006-05-15: Binbin Zhou					c 2006-05-15: Binbin Zhou
c             Modify to accept Beijing 2008 Olympic Game Grid	c             Modify to accept Beijing 2008 Olympic Game Grid
c								c
c 2006-07-21: Binbin Z. Add fog probability			c 2006-07-21: Binbin Z. Add fog probability
c								c
c 2007-01-09: Binbin Z. Add freezing rain for GFS ensemble	c 2007-01-09: Binbin Z. Add freezing rain for GFS ensemble
c								c
c 2007-01-15: Binbin Z. Add Absolute vorticity for global ens	c 2007-01-15: Binbin Z. Add Absolute vorticity for global ens
c 								c 
c 2007-04-05: Binbin Z. Add High resolution WRF testing grid#	c 2007-04-05: Binbin Z. Add High resolution WRF testing grid#
c								c
c 2007-10-09: Binbin Z. Add flight-restriction probability co	c 2007-10-09: Binbin Z. Add flight-restriction probability co
c 								c 
c 2009-04-07: Binbin Z. Adopted for VSREF (by adding member w	c 2009-04-07: Binbin Z. Adopted for VSREF (by adding member w
c								c
c 2009-09-09: Binbin Z. Add convection adapted from Steve W. 	c 2009-09-09: Binbin Z. Add convection adapted from Steve W. 
C								C
c 2010-06-20: Binbin Z. Add precip accumulation for VRSEF ver	c 2010-06-20: Binbin Z. Add precip accumulation for VRSEF ver
c								c
c 2010-8-18:  Binbin Z. Add new fog algorithm (based on Zhou 	c 2010-8-18:  Binbin Z. Add new fog algorithm (based on Zhou 
c 2011-3-18:  Binbin Z. adapt for NARRE-Time Lag  (based on Z	c 2011-3-18:  Binbin Z. adapt for NARRE-Time Lag  (based on Z
c								c
c 2011-04-15: Binbin Z. Add cpat lightning products (based on	c 2011-04-15: Binbin Z. Add cpat lightning products (based on
c 2011-04-18: Binbin Z. Add fire weather probability computat	c 2011-04-18: Binbin Z. Add fire weather probability computat
c 2011-04-18: Binbin Z. Add LLWS code				c 2011-04-18: Binbin Z. Add LLWS code
c 2011-06-10: Binbin Z. Add cptp_dryt based on David B.'s cod	c 2011-06-10: Binbin Z. Add cptp_dryt based on David B.'s cod
c 2011-06-20: Binbin Z. Add severe thunder storm potential ba	c 2011-06-20: Binbin Z. Add severe thunder storm potential ba
c 2012-01-20: Binbin Z. Add missing array to deal with after 	c 2012-01-20: Binbin Z. Add missing array to deal with after 
c                       Modified to work on NSSE 		c                       Modified to work on NSSE 
c 2012-02-21: Binbin Z. Modify accumulated precip computation	c 2012-02-21: Binbin Z. Modify accumulated precip computation
c                       so they become direct vriables in the	c                       so they become direct vriables in the
c 								c 
c 2013-03-28: Binbin Z. Modify to work on grib2 and structure	c 2013-03-28: Binbin Z. Modify to work on grib2 and structure
c                       then process it and pack its ensmeble	c                       then process it and pack its ensmeble
c								c
c 2013-12-21: Binbin Z. Modify  missing array from missing(jf	c 2013-12-21: Binbin Z. Modify  missing array from missing(jf
c                       hiresWRFs are all in same CONUS grid,	c                       hiresWRFs are all in same CONUS grid,
c                       and getGB2 issue (not stop if the fie	c                       and getGB2 issue (not stop if the fie
c								c
c 2014-03-15: Binbin Z. Add Storm-related fileds requested by	c 2014-03-15: Binbin Z. Add Storm-related fileds requested by
c								c
c 2014-04-21: Binbin Z. Add Flash Flood and Intense Rain (FFa	c 2014-04-21: Binbin Z. Add Flash Flood and Intense Rain (FFa
c								c
c$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$	c$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
C$$$								C$$$
C								C

       use grib_mod						       use grib_mod
       include 'parm.inc'					       include 'parm.inc'

      type(gribfield) :: gfld, gfld_temp, gfld_nam,gfld_rap,g |	      type(gribfield) :: gfld, gfld_temp, gfld_nam,gfld_rap,g
							      >	     +                   gfld_ceil
C  raw data							C  raw data
      real,allocatable,dimension(:,:,:)   :: rawdata_mn, rawd	      real,allocatable,dimension(:,:,:)   :: rawdata_mn, rawd
      real,allocatable,dimension(:,:,:)   :: precip          	      real,allocatable,dimension(:,:,:)   :: precip          
      real,allocatable,dimension(:,:,:)   :: mrk_ice         	      real,allocatable,dimension(:,:,:)   :: mrk_ice         
      real,allocatable,dimension(:,:,:)   :: mrk_frz         	      real,allocatable,dimension(:,:,:)   :: mrk_frz         
      real,allocatable,dimension(:,:,:)   :: mrk_snow        	      real,allocatable,dimension(:,:,:)   :: mrk_snow        

C mean								C mean
      real,allocatable,dimension(:,:) :: vrbl_mn             	      real,allocatable,dimension(:,:) :: vrbl_mn             
      real,allocatable,dimension(:,:) :: derv_mn             	      real,allocatable,dimension(:,:) :: derv_mn             

C spread							C spread
      real,allocatable,dimension(:,:) :: vrbl_sp             	      real,allocatable,dimension(:,:) :: vrbl_sp             
      real,allocatable,dimension(:,:) :: derv_sp             	      real,allocatable,dimension(:,:) :: derv_sp             

      real,allocatable,dimension(:) :: ppt3_sp,ppt6_sp,ppt12_	      real,allocatable,dimension(:) :: ppt3_sp,ppt6_sp,ppt12_
     *                                 ppt24_sp,s12_sp		     *                                 ppt24_sp,s12_sp

C probability							C probability
      real,allocatable,dimension(:,:,:) :: vrbl_pr           	      real,allocatable,dimension(:,:,:) :: vrbl_pr           
      real,allocatable,dimension(:,:,:) :: derv_pr           	      real,allocatable,dimension(:,:,:) :: derv_pr           

C Mix,min, 10,25,50 and 90% mean products			C Mix,min, 10,25,50 and 90% mean products
      real,allocatable,dimension(:,:,:) :: mxp8              	      real,allocatable,dimension(:,:,:) :: mxp8              


C others 							C others 
       character*19, allocatable, dimension(:) :: fhead		       character*19, allocatable, dimension(:) :: fhead
       real,allocatable,dimension(:) ::           p03mp01    	       real,allocatable,dimension(:) ::           p03mp01    
       real,allocatable,dimension(:,:)  :: ptype_mn,ptype_pr 	       real,allocatable,dimension(:,:)  :: ptype_mn,ptype_pr 

       real,allocatable,dimension(:,:,:) :: derv_dtra        	       real,allocatable,dimension(:,:,:) :: derv_dtra        
       real,allocatable, dimension(:)    :: Hsfc             	       real,allocatable, dimension(:)    :: Hsfc             
 								 
       integer,allocatable,dimension(:,:)   :: missing       	       integer,allocatable,dimension(:,:)   :: missing       
       integer,allocatable,dimension(:)     :: miss		       integer,allocatable,dimension(:)     :: miss
       real,allocatable,dimension(:) ::           apoint     	       real,allocatable,dimension(:) ::           apoint     

C for get grib size jf=im*jm					C for get grib size jf=im*jm
  								  
       integer iyr,imon,idy,ihr					       integer iyr,imon,idy,ihr
       character*50 gdss(400)					       character*50 gdss(400)
       integer IENS, gribid, kgdss(200), lengds,im,jm,km,jf	       integer IENS, gribid, kgdss(200), lengds,im,jm,km,jf

       integer  leadtime, interval, loutput			       integer  leadtime, interval, loutput

cc%%%%%%%  8. To be added if necessary ......................	cc%%%%%%%  8. To be added if necessary ......................
C original                                                   	C original                                                   
       dimension kgds(25)					       dimension kgds(25)
       character*20 mnout,pmin,pmax,pmod,pp10,pp25,pp50,pp75,	       character*20 mnout,pmin,pmax,pmod,pp10,pp25,pp50,pp75,
       character*20 spout					       character*20 spout
       character*20 prout					       character*20 prout
       character*40 files(50),prcps(50)				       character*40 files(50),prcps(50)
     								     


C for variable table:						C for variable table:
        Integer numvar, nderiv					        Integer numvar, nderiv
        Character*4 vname(maxvar)				        Character*4 vname(maxvar)
        Integer k5(maxvar), k6(maxvar), k4(maxvar)     !k4-ca	        Integer k5(maxvar), k6(maxvar), k4(maxvar)     !k4-ca
        Character*1 Msignal(maxvar), Psignal(maxvar)		        Character*1 Msignal(maxvar), Psignal(maxvar)
        Integer Mlvl(maxvar), MeanLevel(maxvar,maxmlvl),Lm	        Integer Mlvl(maxvar), MeanLevel(maxvar,maxmlvl),Lm
        Integer Plvl(maxvar), ProbLevel(maxvar,maxplvl),Lp	        Integer Plvl(maxvar), ProbLevel(maxvar,maxplvl),Lp
        Integer Tlvl(maxvar),Lth				        Integer Tlvl(maxvar),Lth
        Character*1 op(maxvar)					        Character*1 op(maxvar)
        Real    Thrs(maxvar,maxtlvl)				        Real    Thrs(maxvar,maxtlvl)
        Character*5 eps       					        Character*5 eps       
  								  
c    for derived variables					c    for derived variables
        Character*4 dvname(maxvar)				        Character*4 dvname(maxvar)
        Integer dk5(maxvar), dk6(maxvar), dk4(maxvar)		        Integer dk5(maxvar), dk6(maxvar), dk4(maxvar)
        Character*1 dMsignal(maxvar), dPsignal(maxvar)		        Character*1 dMsignal(maxvar), dPsignal(maxvar)
        Integer dMlvl(maxvar), dMeanLevel(maxvar,maxmlvl)	        Integer dMlvl(maxvar), dMeanLevel(maxvar,maxmlvl)
        Integer dPlvl(maxvar), dProbLevel(maxvar,maxplvl)	        Integer dPlvl(maxvar), dProbLevel(maxvar,maxplvl)
        Character*1 dop(maxvar)					        Character*1 dop(maxvar)
        Integer dTlvl(maxvar)					        Integer dTlvl(maxvar)
        Real    dThrs(maxvar,maxtlvl)				        Real    dThrs(maxvar,maxtlvl)
        Integer MPairLevel(maxvar,maxmlvl,2)			        Integer MPairLevel(maxvar,maxmlvl,2)
        Integer PPairLevel(maxvar,maxplvl,2)			        Integer PPairLevel(maxvar,maxplvl,2)

c   for max,min,10,25,50,90% mean products			c   for max,min,10,25,50,90% mean products
        Character*4 qvname(maxvar)				        Character*4 qvname(maxvar)
        Integer qk5(maxvar), qk6(maxvar), qk4(maxvar)		        Integer qk5(maxvar), qk6(maxvar), qk4(maxvar)
        Character*1 qMsignal(maxvar)				        Character*1 qMsignal(maxvar)
        Integer qMlvl(maxvar), qMeanLevel(maxvar,maxmlvl)	        Integer qMlvl(maxvar), qMeanLevel(maxvar,maxmlvl)
        							        
        real  weight(30)                               		        real  weight(30)                               
        character*20 filenames					        character*20 filenames
        character*2 cfhr                                     	        character*2 cfhr                                     
        integer est                                 !east tim	        integer est                                 !east tim
        integer ifunit(50),ipunit(50)               !member, 	        integer ifunit(50),ipunit(50)               !member, 
        character*2 cycle(24)					        character*2 cycle(24)
        character*7 mbrname(50)					        character*7 mbrname(50)

        integer jptyp2(4)                           !for prec	        integer jptyp2(4)                           !for prec
        integer iqout(8) 					        integer iqout(8) 

        integer ierr_open_punit(30),ierr_open_funit(30),	        integer ierr_open_punit(30),ierr_open_funit(30),
     +          ierr_open(30) 					     +          ierr_open(30) 

        common /tbl/numvar,					        common /tbl/numvar,
     +              vname,k4,k5,k6,Mlvl,Plvl,Tlvl,		     +              vname,k4,k5,k6,Mlvl,Plvl,Tlvl,
     +              MeanLevel,ProbLevel,Thrs,			     +              MeanLevel,ProbLevel,Thrs,
     +              Msignal,Psignal,op				     +              Msignal,Psignal,op
                                                             	                                                             
        common /dtbl/nderiv,					        common /dtbl/nderiv,
     +              dvname,dk4,dk5,dk6,dMlvl,dPlvl,dTlvl,	     +              dvname,dk4,dk5,dk6,dMlvl,dPlvl,dTlvl,
     +              dMeanLevel,dProbLevel,dThrs,		     +              dMeanLevel,dProbLevel,dThrs,
     +              dMsignal,dPsignal,MPairLevel,PPairLevel,d	     +              dMsignal,dPsignal,MPairLevel,PPairLevel,d
                           					                           
     								     
        common /qtbl/nmxp,					        common /qtbl/nmxp,
     +              qvname,qk4,qk5,qk6,qMlvl,			     +              qvname,qk4,qk5,qk6,qMlvl,
     +              qMeanLevel,qMsignal				     +              qMeanLevel,qMsignal
                                                             	                                                             
        data (iqout(i),i=1,8)					        data (iqout(i),i=1,8)
     +  /301,302,303,304,305,306,307,308/			     +  /301,302,303,304,305,306,307,308/

        data (cycle(i),i=1,24)					        data (cycle(i),i=1,24)
     +  /'00','01','02','03','04','05','06','07','08',		     +  /'00','01','02','03','04','05','06','07','08',
     +   '09','10','11','12','13','14','15','16','17',		     +   '09','10','11','12','13','14','15','16','17',
     +   '18','19','20','21','22','23'/				     +   '18','19','20','21','22','23'/

        data (jptyp2(i),i=1,4)					        data (jptyp2(i),i=1,4)
     +  /192,193,194,195/                     !rain, frzr, ic	     +  /192,193,194,195/                     !rain, frzr, ic

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c (I)   Read table file to get wanted ensemble variable infor	c (I)   Read table file to get wanted ensemble variable infor
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

        numvar=0						        numvar=0
        nderiv=0						        nderiv=0
        nmxp=0							        nmxp=0
        ierr_open_punit=0					        ierr_open_punit=0
        ierr_open_funit=0					        ierr_open_funit=0
        ierr_open=0						        ierr_open=0

        nunit=101						        nunit=101
        open (nunit, file='variable.tbl', status='old')		        open (nunit, file='variable.tbl', status='old')
        							        
        write(*,*) 'reading variable.tbl ...'                	        write(*,*) 'reading variable.tbl ...'                
        call readtbl(nunit)					        call readtbl(nunit)
        write(*,*) 'read variable.tbl done'			        write(*,*) 'read variable.tbl done'

        close(nunit)						        close(nunit)

c        write(*,*) 'Check rirect variable reading:'		c        write(*,*) 'Check rirect variable reading:'
c        do i = 1, numvar					c        do i = 1, numvar
c          write(*,*) vname(i),k4(i),k5(i), k6(i),Msignal(i),	c          write(*,*) vname(i),k4(i),k5(i), k6(i),Msignal(i),
c     +                 (MeanLevel(i,j),j=1,Mlvl(i)),		c     +                 (MeanLevel(i,j),j=1,Mlvl(i)),
c     +    Psignal(i), Plvl(i), (ProbLevel(i,j),j=1,Plvl(i)),	c     +    Psignal(i), Plvl(i), (ProbLevel(i,j),j=1,Plvl(i)),
c     +    op(i), Tlvl(i),   (Thrs(i,j),j=1,Tlvl(i))		c     +    op(i), Tlvl(i),   (Thrs(i,j),j=1,Tlvl(i))
c151      format(a4,1x,3i4,a2,i2,<Mlvl(i)>(1x,i4),a2,i2,<Plvl	c151      format(a4,1x,3i4,a2,i2,<Mlvl(i)>(1x,i4),a2,i2,<Plvl
c     +   a2, i2, <Tlvl(i)>(1x,F7.1))   			c     +   a2, i2, <Tlvl(i)>(1x,F7.1))   
c        end do							c        end do

c        write(*,*) 'Check derived variable reading:'		c        write(*,*) 'Check derived variable reading:'
c        do i = 1, nderiv					c        do i = 1, nderiv
c         if(dk6(i).eq.101) then				c         if(dk6(i).eq.101) then
c           write(*,*) dvname(i),dk4(i),dk5(i), dk6(i),dMsign	c           write(*,*) dvname(i),dk4(i),dk5(i), dk6(i),dMsign
c     +               dMlvl(i),(dMeanLevel(i,j),j=1,dMlvl(i))	c     +               dMlvl(i),(dMeanLevel(i,j),j=1,dMlvl(i))
c     +              (MPairLevel(i,j,1),j=1,dMlvl(i)),		c     +              (MPairLevel(i,j,1),j=1,dMlvl(i)),
c     +              (MPairLevel(i,j,2),j=1,dMlvl(i)),		c     +              (MPairLevel(i,j,2),j=1,dMlvl(i)),
c     +          dPsignal(i),dPlvl(i),(dProbLevel(i,j),j=1,dP	c     +          dPsignal(i),dPlvl(i),(dProbLevel(i,j),j=1,dP
c     +              (PPairLevel(i,j,1),j=1,dPlvl(i)),		c     +              (PPairLevel(i,j,1),j=1,dPlvl(i)),
c     +              (PPairLevel(i,j,2),j=1,dPlvl(i)),		c     +              (PPairLevel(i,j,2),j=1,dPlvl(i)),
c     +              dop(i), dTlvl(i),   (dThrs(i,j),j=1,dTlv	c     +              dop(i), dTlvl(i),   (dThrs(i,j),j=1,dTlv
c         else							c         else
c           write(*,*) dvname(i),dk4(i),dk5(i), dk6(i),dMsign	c           write(*,*) dvname(i),dk4(i),dk5(i), dk6(i),dMsign
c     +              dMlvl(i),(dMeanLevel(i,j),j=1,dMlvl(i)),	c     +              dMlvl(i),(dMeanLevel(i,j),j=1,dMlvl(i)),
c     +          dPsignal(i),dPlvl(i),(dProbLevel(i,j),j=1,dP	c     +          dPsignal(i),dPlvl(i),(dProbLevel(i,j),j=1,dP
c     +             dop(i), dTlvl(i),   (dThrs(i,j),j=1,dTlvl	c     +             dop(i), dTlvl(i),   (dThrs(i,j),j=1,dTlvl
c         end if						c         end if
c        end do							c        end do
c								c
c        write(*,*) 'Check max,min,10,25,50,75,90% mean produ	c        write(*,*) 'Check max,min,10,25,50,75,90% mean produ
c        do i = 1, nmxp						c        do i = 1, nmxp
c         write(*,*)qvname(i),qk4(i),qk5(i),qk6(i),qMsignal(i	c         write(*,*)qvname(i),qk4(i),qk5(i),qk6(i),qMsignal(i
c     +        qMlvl(i),(qMeanLevel(i,j),j=1,qMlvl(i))		c     +        qMlvl(i),(qMeanLevel(i,j),j=1,qMlvl(i))
c        end do							c        end do


ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c (II): Read filename file to get # of ensemble available, gr	c (II): Read filename file to get # of ensemble available, gr
c       last forecast time, forecast outout interval and grib	c       last forecast time, forecast outout interval and grib
c       so that arrays can be dinamically allocatable		c       so that arrays can be dinamically allocatable
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


       filenames="filename" 					       filenames="filename" 
       write(*,*) 'read ',filenames				       write(*,*) 'read ',filenames
       open(1, file=filenames, status='old')			       open(1, file=filenames, status='old')
       read(1,*) iyr,imon,idy,ihr,ifhr,gribid,KM,leadtime,int	       read(1,*) iyr,imon,idy,ihr,ifhr,gribid,KM,leadtime,int
     +             loutput					     +             loutput
       write(*,*)iyr,imon,idy,ihr,ifhr,gribid,KM,leadtime,int	       write(*,*)iyr,imon,idy,ihr,ifhr,gribid,KM,leadtime,int
     +             loutput					     +             loutput

       !read(1,*) (cfhr(k),k=1,loutput) 			       !read(1,*) (cfhr(k),k=1,loutput) 

       IENS=0							       IENS=0
       do irun=1,50						       do irun=1,50
         read(1,301,END=302) weight(irun),files(irun),mbrname	         read(1,301,END=302) weight(irun),files(irun),mbrname
         write(*,301) weight(irun), files(irun),mbrname(irun)	         write(*,301) weight(irun), files(irun),mbrname(irun)
         IENS=IENS+1						         IENS=IENS+1
         prcps(irun)='prcip'//files(irun)(5:17)              	         prcps(irun)='prcip'//files(irun)(5:17)              
         write(*,*) weight(irun), files(irun),prcps(irun)	         write(*,*) weight(irun), files(irun),prcps(irun)
       end do							       end do

       close (1)						       close (1)

  301  format(f7.2, 1x, a17,4x,a7)				  301  format(f7.2, 1x, a17,4x,a7)
  302  continue							  302  continue
      write(*,*) 'IENS=',IENS, (weight(irun),irun=1,iens)	      write(*,*) 'IENS=',IENS, (weight(irun),irun=1,iens)

      DO 3000 itime=ifhr,ifhr          !Here ifhr is forecast	      DO 3000 itime=ifhr,ifhr          !Here ifhr is forecast

         write(cfhr,'(i2.2)') itime				         write(cfhr,'(i2.2)') itime

        print*,'Initializing variables'				        print*,'Initializing variables'

       est = ihr + itime - 6                                 	       est = ihr + itime - 6                                 
       if (est.lt.0) est= est + 24 				       if (est.lt.0) est= est + 24 


CCCC Binbin Zhou Note:						CCCC Binbin Zhou Note:

       if(gribid.eq.255) then   !For HRRR grid			       if(gribid.eq.255) then   !For HRRR grid
         im=1799						         im=1799
         jm=1059						         jm=1059
         jf=im*jm						         jf=im*jm
         dx=3000.0						         dx=3000.0
         dy=3000.0						         dy=3000.0
       else							       else
         call makgds(gribid, kgdss, gdss, lengds, ier)		         call makgds(gribid, kgdss, gdss, lengds, ier)
         im=kgdss(2)						         im=kgdss(2)
         jm=kgdss(3)						         jm=kgdss(3)
         jf=kgdss(2)*kgdss(3)					         jf=kgdss(2)*kgdss(3)
         dx=1.*kgdss(8)						         dx=1.*kgdss(8)
         dy=1.*kgdss(9)						         dy=1.*kgdss(9)
       end if							       end if
 								 
       write(*,*) 'im, jm, jf,dx,dy =', im, jm, jf,dx,dy	       write(*,*) 'im, jm, jf,dx,dy =', im, jm, jf,dx,dy
       write(*,*) 'leadtime, interval, loutput=', 		       write(*,*) 'leadtime, interval, loutput=', 
     +             leadtime, interval, loutput			     +             leadtime, interval, loutput

       if (.NOT.allocated(fhead)) then				       if (.NOT.allocated(fhead)) then
        allocate(fhead(iens))   				        allocate(fhead(iens))   
       end if							       end if
       if (.NOT.allocated(apoint)) then				       if (.NOT.allocated(apoint)) then
        allocate(apoint(iens)) 					        allocate(apoint(iens)) 
       end if							       end if
       if (.NOT.allocated(missing)) then			       if (.NOT.allocated(missing)) then
        allocate(missing(maxvar,iens))				        allocate(missing(maxvar,iens))
       end if							       end if
       if (.NOT.allocated(miss)) then				       if (.NOT.allocated(miss)) then
        allocate(miss(iens))					        allocate(miss(iens))
       end if							       end if

       if (.NOT.allocated(p03mp01)) then			       if (.NOT.allocated(p03mp01)) then
        allocate(p03mp01(jf))					        allocate(p03mp01(jf))
       end if							       end if



       eps=files(1)(1:4)					       eps=files(1)(1:4)
       missing=0 						       missing=0 
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c (III): Open all ensemble data files 				c (III): Open all ensemble data files 
c In these lines put here, we need the date and time of the f	c In these lines put here, we need the date and time of the f
c the name of the file.  We need to open the file.  Then we c	c the name of the file.  We need to open the file.  Then we c
c the correct location of the forecast in the forecast file. 	c the correct location of the forecast in the forecast file. 
c is an ensemble, then we also need another loop for the fore	c is an ensemble, then we also need another loop for the fore
c (cntl, n1, p1, etc.).  That loop should be inside the date/	c (cntl, n1, p1, etc.).  That loop should be inside the date/


       do 500 irun=1,iens					       do 500 irun=1,iens

        ifunit(irun)=10+irun					        ifunit(irun)=10+irun
        call baopenr(ifunit(irun),files(irun),ier1)		        call baopenr(ifunit(irun),files(irun),ier1)
        write(*,*)'open#',irun,ifunit(irun),files(irun),'err=	        write(*,*)'open#',irun,ifunit(irun),files(irun),'err=
        if (ier1.ne.0) ierr_open_funit(irun)=ier1		        if (ier1.ne.0) ierr_open_funit(irun)=ier1

        ipunit(irun)=50+irun					        ipunit(irun)=50+irun
        call baopenr(ipunit(irun),prcps(irun),ier2)		        call baopenr(ipunit(irun),prcps(irun),ier2)
        write(*,*)'open#',irun,ipunit(irun),prcps(irun),'err=	        write(*,*)'open#',irun,ipunit(irun),prcps(irun),'err=
        if (ier2.ne.0) ierr_open_punit(irun)=ier2		        if (ier2.ne.0) ierr_open_punit(irun)=ier2

500     continue 						500     continue 

        write(*,*) 'numvar=',numvar				        write(*,*) 'numvar=',numvar

        imean=201						        imean=201
        isprd=202						        isprd=202
        iprob=203						        iprob=203

      mnout=trim(eps)//'.mean.t'//cycle(ihr+1)//'z'//'.f'//cf	      mnout=trim(eps)//'.mean.t'//cycle(ihr+1)//'z'//'.f'//cf
      spout=trim(eps)//'.sprd.t'//cycle(ihr+1)//'z'//'.f'//cf	      spout=trim(eps)//'.sprd.t'//cycle(ihr+1)//'z'//'.f'//cf
      prout=trim(eps)//'.prob.t'//cycle(ihr+1)//'z'//'.f'//cf	      prout=trim(eps)//'.prob.t'//cycle(ihr+1)//'z'//'.f'//cf

      call baopen (imean, mnout, iret)				      call baopen (imean, mnout, iret)
      if (iret.ne.0) write(*,*) 'open ', mnout, 'err=', iret	      if (iret.ne.0) write(*,*) 'open ', mnout, 'err=', iret
      call baopen (isprd, spout, iret)				      call baopen (isprd, spout, iret)
      if (iret.ne.0) write(*,*) 'open ', spout, 'err=', iret	      if (iret.ne.0) write(*,*) 'open ', spout, 'err=', iret
      call baopen (iprob, prout, iret)				      call baopen (iprob, prout, iret)
      if (iret.ne.0) write(*,*) 'open ', prout, 'err=', iret	      if (iret.ne.0) write(*,*) 'open ', prout, 'err=', iret


ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c (IV) Main tasks:						c (IV) Main tasks:
c  Loop1: process direct variables				c  Loop1: process direct variables
c  Loop2: process derived variables				c  Loop2: process derived variables
c  Loop3: process mxp variables (min,max,mod, 10, 250 50 75 9	c  Loop3: process mxp variables (min,max,mod, 10, 250 50 75 9

c  Loop 1: for direct variables					c  Loop 1: for direct variables
c   1-0: Allocate nesessary arrays				c   1-0: Allocate nesessary arrays
c   1-1: In this loop, one field (nv) data are read from all 	c   1-1: In this loop, one field (nv) data are read from all 
c   1-2: Compute its mean, spread, and prob,			c   1-2: Compute its mean, spread, and prob,
c   1-3: Pack them into output mean, spread, prob files   	c   1-3: Pack them into output mean, spread, prob files   
c   then, loop for next field					c   then, loop for next field
c   1-4: deallocate allocated arrays 				c   1-4: deallocate allocated arrays 
c								c
       DO 2001 nv = 1, numvar					       DO 2001 nv = 1, numvar

c       write(*,*) 'nv Mlvl(nv),Plvl(nv),Tlvl(nv)=',		c       write(*,*) 'nv Mlvl(nv),Plvl(nv),Tlvl(nv)=',
c     +    nv, Mlvl(nv),Plvl(nv),Tlvl(nv)			c     +    nv, Mlvl(nv),Plvl(nv),Tlvl(nv)

c  Loop  1-0: Allocate nesessary arrays				c  Loop  1-0: Allocate nesessary arrays
         if (.NOT.allocated(rawdata_mn)) then			         if (.NOT.allocated(rawdata_mn)) then
           allocate (rawdata_mn(jf,iens,Mlvl(nv)))		           allocate (rawdata_mn(jf,iens,Mlvl(nv)))
         end if							         end if
         if (.NOT.allocated(rawdata_pr)) then			         if (.NOT.allocated(rawdata_pr)) then
           allocate (rawdata_pr(jf,iens,plvl(nv)))		           allocate (rawdata_pr(jf,iens,plvl(nv)))
         end if							         end if
        if (.NOT.allocated(vrbl_mn)) then			        if (.NOT.allocated(vrbl_mn)) then
           Lm=max(1,Mlvl(nv))                !Keep at least o	           Lm=max(1,Mlvl(nv))                !Keep at least o
           allocate (vrbl_mn(jf,Lm))         !in case Mlvl(nv	           allocate (vrbl_mn(jf,Lm))         !in case Mlvl(nv
         end if							         end if
        if (.NOT.allocated(vrbl_sp)) then			        if (.NOT.allocated(vrbl_sp)) then
           Lm=max(1,Mlvl(nv))					           Lm=max(1,Mlvl(nv))
           allocate (vrbl_sp(jf,Lm))				           allocate (vrbl_sp(jf,Lm))
         end if							         end if
        if (.NOT.allocated(vrbl_pr)) then			        if (.NOT.allocated(vrbl_pr)) then
           Lp=max(1,Plvl(nv))					           Lp=max(1,Plvl(nv))
           Lth=max(1,Tlvl(nv))					           Lth=max(1,Tlvl(nv))
           allocate (vrbl_pr(jf,Lp,Lth))			           allocate (vrbl_pr(jf,Lp,Lth))
         end if							         end if


         							         
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Loop 1-1: Read direct variable's GRIB2 data from all member	c Loop 1-1: Read direct variable's GRIB2 data from all member



        DO 1001 irun=1,iens         ! members			        DO 1001 irun=1,iens         ! members

         !apcp1h,apcp3hr,apcp6hr,apcp12,apcp24 have been put 	         !apcp1h,apcp3hr,apcp6hr,apcp12,apcp24 have been put 
         !every members as direct variable			         !every members as direct variable

          if ((k4(nv).eq.2.and.k5(nv).eq.222).or.		          if ((k4(nv).eq.2.and.k5(nv).eq.222).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.223).or.		     +        (k4(nv).eq.2.and.k5(nv).eq.223).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.198).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.198).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.195).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.195).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.196).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.196).or.
     +        (k4(nv).eq.7.and.k5(nv).eq.199).or.		     +        (k4(nv).eq.7.and.k5(nv).eq.199).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.220).or.		     +        (k4(nv).eq.2.and.k5(nv).eq.220).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.221) ) then		     +        (k4(nv).eq.2.and.k5(nv).eq.221) ) then

              if(mbrname(irun).eq.'hrrrgsd') then ! These 8 f	              if(mbrname(irun).eq.'hrrrgsd') then ! These 8 f
                 rawdata_pr(:,irun,:)=-9999.0			                 rawdata_pr(:,irun,:)=-9999.0
                 rawdata_mn(:,irun,:)=-9999.0			                 rawdata_mn(:,irun,:)=-9999.0
                 goto 1001					                 goto 1001
              end if						              end if

           end if  						           end if  

          if((k4(nv).eq.1.and.k5(nv).eq.8).or.          !Chec	          if((k4(nv).eq.1.and.k5(nv).eq.8).or.          !Chec
     +      (k4(nv).eq.1.and.k5(nv).eq.15)) then		     +      (k4(nv).eq.1.and.k5(nv).eq.15)) then

c         write(*,*) 'get APCP GRIB2 data for member ', irun	c         write(*,*) 'get APCP GRIB2 data for member ', irun

           jpdtn=8						           jpdtn=8
           jpd1=k4(nv)						           jpd1=k4(nv)
           jpd2=k5(nv)						           jpd2=k5(nv)
           jpd10=k6(nv)						           jpd10=k6(nv)
           !jpd12 is determined by a specific level MeanLevel	           !jpd12 is determined by a specific level MeanLevel

           if (vname(nv).eq.'AP1h'.or.vname(nv).eq.'SN1h') th	           if (vname(nv).eq.'AP1h'.or.vname(nv).eq.'SN1h') th
             jpd27=1						             jpd27=1
           else if (vname(nv).eq.'AP3h'.or.vname(nv).eq.'SN3h	           else if (vname(nv).eq.'AP3h'.or.vname(nv).eq.'SN3h
             if(ifhr.lt.3) goto 222				             if(ifhr.lt.3) goto 222
             jpd27=3						             jpd27=3
           else if (vname(nv).eq.'AP6h'.or.vname(nv).eq.'SN6h	           else if (vname(nv).eq.'AP6h'.or.vname(nv).eq.'SN6h
             if(ifhr.lt.6) goto 222				             if(ifhr.lt.6) goto 222
             jpd27=6						             jpd27=6
           else if (vname(nv).eq.'AP12'.or.vname(nv).eq.'SN12	           else if (vname(nv).eq.'AP12'.or.vname(nv).eq.'SN12
             if(ifhr.lt.12) goto 222				             if(ifhr.lt.12) goto 222
             jpd27=12						             jpd27=12
           else if (vname(nv).eq.'AP24'.or.vname(nv).eq.'SN24	           else if (vname(nv).eq.'AP24'.or.vname(nv).eq.'SN24
             if(ifhr.lt.24) goto 222				             if(ifhr.lt.24) goto 222
             jpd27=24						             jpd27=24
           else							           else
             write(*,*) 'Using wrong APCP name!'		             write(*,*) 'Using wrong APCP name!'
           end if						           end if

           igrb2=ipunit(irun)					           igrb2=ipunit(irun)
           ierr_open(irun)=ierr_open_punit(irun)		           ierr_open(irun)=ierr_open_punit(irun)
          else  						          else  

           jpdtn=0						           jpdtn=0

          if ((k4(nv).eq.2.and.k5(nv).eq.222).or.		          if ((k4(nv).eq.2.and.k5(nv).eq.222).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.223).or.		     +        (k4(nv).eq.2.and.k5(nv).eq.223).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.198).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.198).or.
     +        (k4(nv).eq.7.and.k5(nv).eq.199).or.		     +        (k4(nv).eq.7.and.k5(nv).eq.199).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.220).or.		     +        (k4(nv).eq.2.and.k5(nv).eq.220).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.221) ) then		     +        (k4(nv).eq.2.and.k5(nv).eq.221) ) then
              jpdtn=8						              jpdtn=8
           end if						           end if

           jpd1=k4(nv)						           jpd1=k4(nv)
           jpd2=k5(nv)						           jpd2=k5(nv)
           !jpd12 is determined by a specific level MeanLevel	           !jpd12 is determined by a specific level MeanLevel
           jpd10=k6(nv)						           jpd10=k6(nv)
           jpd27=-9999						           jpd27=-9999

           igrb2=ifunit(irun)					           igrb2=ifunit(irun)
           ierr_open(irun)=ierr_open_funit(irun)		           ierr_open(irun)=ierr_open_funit(irun)

          end if						          end if

         do 501 lv=1,Mlvl(nv)					         do 501 lv=1,Mlvl(nv)

          jpd12=MeanLevel(nv,lv)				          jpd12=MeanLevel(nv,lv)

          if(mbrname(irun).eq.'hrrrgsd'.and.k4(nv).eq.16.	          if(mbrname(irun).eq.'hrrrgsd'.and.k4(nv).eq.16.
     +                            and.k5(nv).eq.197) then !HR	     +                            and.k5(nv).eq.197) then !HR
            jpd1=3						            jpd1=3
            jpd2=193						            jpd2=193
            jpd10=3						            jpd10=3
            jpd12=-9999						            jpd12=-9999
          end if  						          end if  

          if (ierr_open(irun).eq.0) then			          if (ierr_open(irun).eq.0) then
            call readGB2(igrb2,jpdtn,jpd1,jpd2,jpd10,jpd12,jp	            call readGB2(igrb2,jpdtn,jpd1,jpd2,jpd10,jpd12,jp
     +            gfld, jret)					     +            gfld, jret)
            if (jret.ne.0) goto 501				            if (jret.ne.0) goto 501
            rawdata_mn(:,irun,lv)=gfld%fld			            rawdata_mn(:,irun,lv)=gfld%fld
            if (nv.eq.1.and.irun.eq.8) gfld_nam=gfld  !NAM's 	            if (nv.eq.1.and.irun.eq.8) gfld_nam=gfld  !NAM's 
            if (nv.eq.1.and.irun.eq.1) gfld_rap=gfld  !RAP's 	            if (nv.eq.1.and.irun.eq.1) gfld_rap=gfld  !RAP's 
c            if (k4(nv).eq.19.and.k5(nv).eq.0.and.k6(nv).eq.1 |	            if (k4(nv).eq.19.and.k5(nv).eq.0.and.k6(nv).eq.1 
c     +          .and.irun.eq.8)  gfld_vis=gfld		      |	     +          .and.irun.eq.8)  gfld_vis=gfld
							      >	            if (k4(nv).eq.3.and.k5(nv).eq.5                  
							      >	     +          .and.irun.eq.8)  gfld_ceil=gfld
							      >
          end if						          end if
501      continue						501      continue

         do 502 lv=1,Plvl(nv)					         do 502 lv=1,Plvl(nv)

          jpd12=probLevel(nv,lv)				          jpd12=probLevel(nv,lv)

           if(mbrname(irun).eq.'hrrrgsd'.and.k4(nv).eq.16.	           if(mbrname(irun).eq.'hrrrgsd'.and.k4(nv).eq.16.
     +                            and.k5(nv).eq.197) then !HR	     +                            and.k5(nv).eq.197) then !HR
            jpd1=3						            jpd1=3
            jpd2=193						            jpd2=193
            jpd10=3						            jpd10=3
            jpd12=-9999						            jpd12=-9999
           end if						           end if

           if (ierr_open(irun).eq.0) then			           if (ierr_open(irun).eq.0) then
            call readGB2(igrb2,jpdtn,jpd1,jpd2,jpd10,jpd12,jp	            call readGB2(igrb2,jpdtn,jpd1,jpd2,jpd10,jpd12,jp
     +          gfld,kret)					     +          gfld,kret)
            if (kret.eq.0) then					            if (kret.eq.0) then
             rawdata_pr(:,irun,lv)=gfld%fld			             rawdata_pr(:,irun,lv)=gfld%fld
            else 						            else 
              if (jpd1.eq.16.and.jpd2.eq.196        !RAP REFC	              if (jpd1.eq.16.and.jpd2.eq.196        !RAP REFC
     +           .and.jpd10.eq.200) then			     +           .and.jpd10.eq.200) then
                write(*,*) 'Try jpd10=10 to read REFC RAP',ir	                write(*,*) 'Try jpd10=10 to read REFC RAP',ir
                call readGB2(igrb2,jpdtn,jpd1,jpd2,10,jpd12,j	                call readGB2(igrb2,jpdtn,jpd1,jpd2,10,jpd12,j
     +          gfld,kret)					     +          gfld,kret)
               if (kret.eq.0) rawdata_pr(:,irun,lv)=gfld%fld	               if (kret.eq.0) rawdata_pr(:,irun,lv)=gfld%fld
              end if        					              end if        
            end if						            end if
          end if 						          end if 

502       continue       					502       continue       
 								 
         !Just correc some variables 				         !Just correc some variables 
         if(jret.ne.0.or.kret.ne.0) then			         if(jret.ne.0.or.kret.ne.0) then
           missing(nv,irun)=1					           missing(nv,irun)=1
           goto 1001						           goto 1001
         end if 						         end if 

         do igrid=1,jf						         do igrid=1,jf
          do lv = 1, Mlvl(nv)					          do lv = 1, Mlvl(nv)

            if(k4(nv).eq.7.and.k5(nv).eq.192) then		            if(k4(nv).eq.7.and.k5(nv).eq.192) then
              rawdata_mn(igrid,irun,lv) = rawdata_mn(igrid,ir	              rawdata_mn(igrid,irun,lv) = rawdata_mn(igrid,ir
     +                                                       	     +                                                       
            end if						            end if

            if(k4(nv).eq.3.and.k5(nv).eq.5.and.(k6(nv).eq.2.o	            if(k4(nv).eq.3.and.k5(nv).eq.5.and.(k6(nv).eq.2.o
     +        k6(nv).eq.3))                                  	     +        k6(nv).eq.3))                                  

              if (rawdata_mn(igrid,irun,lv).le.0.0) then     	              if (rawdata_mn(igrid,irun,lv).le.0.0) then     
                 rawdata_mn(igrid,irun,lv) = 20000.0		                 rawdata_mn(igrid,irun,lv) = 20000.0
              end if						              end if
            end if						            end if

           end do						           end do
 								 
           do lv = 1, Plvl(nv)					           do lv = 1, Plvl(nv)
             if(k4(nv).eq.7.and.k5(nv).eq.192) then		             if(k4(nv).eq.7.and.k5(nv).eq.192) then
               rawdata_pr(igrid,irun,lv) = rawdata_pr(igrid,i	               rawdata_pr(igrid,irun,lv) = rawdata_pr(igrid,i
     +                                                       	     +                                                       
             end if						             end if

            if(k4(nv).eq.3.and.k5(nv).eq.5.and.(k6(nv).eq.2.o	            if(k4(nv).eq.3.and.k5(nv).eq.5.and.(k6(nv).eq.2.o
     +        k6(nv).eq.3))                                  	     +        k6(nv).eq.3))                                  

              if (rawdata_pr(igrid,irun,lv).le.0.0) then     	              if (rawdata_pr(igrid,irun,lv).le.0.0) then     
                rawdata_pr(igrid,irun,lv) = 20000.0		                rawdata_pr(igrid,irun,lv) = 20000.0
              end if						              end if
            end if						            end if
           end do						           end do

         end do							         end do

1001     continue  !end of iens loop for getting GRIB2 data f	1001     continue  !end of iens loop for getting GRIB2 data f
       								       
         write(*,*) 'Get direct variable data done for', nv	         write(*,*) 'Get direct variable data done for', nv

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Loop 1-2:   Compute mean/spread/prob for this direct variab	c Loop 1-2:   Compute mean/spread/prob for this direct variab

         vrbl_mn=0.						         vrbl_mn=0.
         vrbl_sp=0.						         vrbl_sp=0.
         vrbl_pr=0.						         vrbl_pr=0.

        IF(trim(Msignal(nv)).eq.'M') THEN			        IF(trim(Msignal(nv)).eq.'M') THEN
         							         
         do lv = 1, Mlvl(nv)					         do lv = 1, Mlvl(nv)
          do igrid=1,jf						          do igrid=1,jf

           apoint = rawdata_mn(igrid,:,lv)			           apoint = rawdata_mn(igrid,:,lv)
           miss = missing(nv,:)					           miss = missing(nv,:)

          if ((k4(nv).eq.2.and.k5(nv).eq.222).or.   !These fi	          if ((k4(nv).eq.2.and.k5(nv).eq.222).or.   !These fi
     +        (k4(nv).eq.2.and.k5(nv).eq.223).or.		     +        (k4(nv).eq.2.and.k5(nv).eq.223).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.198).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.198).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.195).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.195).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.196).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.196).or.
     +        (k4(nv).eq.7.and.k5(nv).eq.199).or.		     +        (k4(nv).eq.7.and.k5(nv).eq.199).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.220).or.		     +        (k4(nv).eq.2.and.k5(nv).eq.220).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.221) ) then		     +        (k4(nv).eq.2.and.k5(nv).eq.221) ) then
             do ie=1,iens					             do ie=1,iens
               if(mbrname(ie).eq.'hrrrgsd') then		               if(mbrname(ie).eq.'hrrrgsd') then
                miss(ie)=1					                miss(ie)=1
               end if						               end if
             end do						             end do
          end if						          end if


           if(k4(nv).eq.19.and.k5(nv).eq.0) then  ! Visibilit	           if(k4(nv).eq.19.and.k5(nv).eq.0) then  ! Visibilit
             do ie =1,iens					             do ie =1,iens
               if(apoint(ie).lt.1.0) miss(ie)=1   !exclude sp	               if(apoint(ie).lt.1.0) miss(ie)=1   !exclude sp
             end do						             end do
							      >
							      >	              
             call get_cond_mean (apoint,iens,24056.0,amean,as	             call get_cond_mean (apoint,iens,24056.0,amean,as
     +                              miss, weight) 		     +                              miss, weight) 

           else if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.	           else if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.
             call get_cond_mean (apoint,iens,20000.0,amean,as	             call get_cond_mean (apoint,iens,20000.0,amean,as
     +                               miss,weight)		     +                               miss,weight)

           else if(k4(nv).eq.6.and.k5(nv).eq.6.and.k6(nv).eq.	           else if(k4(nv).eq.6.and.k5(nv).eq.6.and.k6(nv).eq.
                apoint = apoint * 1000.0                     	                apoint = apoint * 1000.0                     
                call get_cond_mean_lwc(apoint,iens,0.0,amean,	                call get_cond_mean_lwc(apoint,iens,0.0,amean,
     +                               miss,weight)		     +                               miss,weight)

           else if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.	           else if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.
                do i =1,iens					                do i =1,iens
                 if(apoint(i).le.0.) apoint(i)=20000.0		                 if(apoint(i).le.0.) apoint(i)=20000.0
                end do						                end do
                call get_cond_mean (apoint,iens,20000.0,amean	                call get_cond_mean (apoint,iens,20000.0,amean
     +                               miss,weight)		     +                               miss,weight)

           else if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.	           else if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.
                do i =1,iens					                do i =1,iens
                 if(apoint(i).le.0.) apoint(i)=20000.0		                 if(apoint(i).le.0.) apoint(i)=20000.0
                end do						                end do
                call get_cond_mean (apoint,iens,20000.0,amean	                call get_cond_mean (apoint,iens,20000.0,amean
     +                               miss,weight)		     +                               miss,weight)

           else							           else
             							             
             call getmean(apoint,iens,amean,aspread,miss,weig	             call getmean(apoint,iens,amean,aspread,miss,weig

           end if						           end if

            vrbl_mn(igrid,lv)=amean				            vrbl_mn(igrid,lv)=amean
            vrbl_sp(igrid,lv)=aspread				            vrbl_sp(igrid,lv)=aspread

            end do 						            end do 
  								  
c         write(*,'(a4,10f9.2)')'MEAN',(vrbl_mn(i,lv),i=10001 |	         !write(*,*)'Direct MEAN',(vrbl_mn(i,lv),i=20001,2001
c         write(*,'(a4,10f9.2)')'SPRD',(vrbl_sp(i,lv),i=10001 |	         !write(*,'(a4,10f9.2)')'SPRD',(vrbl_sp(i,lv),i=10001

           end do  !end if Mlvl					           end do  !end if Mlvl

        END IF							        END IF

        IF (trim(Psignal(nv)).eq.'P') THEN			        IF (trim(Psignal(nv)).eq.'P') THEN

         do lv = 1, Plvl(nv)					         do lv = 1, Plvl(nv)
          do lt = 1, Tlvl(nv)					          do lt = 1, Tlvl(nv)

           do igrid=1,jf					           do igrid=1,jf

            apoint = rawdata_pr(igrid,:,lv)			            apoint = rawdata_pr(igrid,:,lv)
            miss = missing(nv,:)				            miss = missing(nv,:)

          if ((k4(nv).eq.2.and.k5(nv).eq.222).or.		          if ((k4(nv).eq.2.and.k5(nv).eq.222).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.223).or.		     +        (k4(nv).eq.2.and.k5(nv).eq.223).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.198).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.198).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.195).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.195).or.
     +        (k4(nv).eq.16.and.k5(nv).eq.196).or.		     +        (k4(nv).eq.16.and.k5(nv).eq.196).or.
     +        (k4(nv).eq.7.and.k5(nv).eq.199).or.		     +        (k4(nv).eq.7.and.k5(nv).eq.199).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.220).or.		     +        (k4(nv).eq.2.and.k5(nv).eq.220).or.
     +        (k4(nv).eq.2.and.k5(nv).eq.221) ) then		     +        (k4(nv).eq.2.and.k5(nv).eq.221) ) then
             do ie=1,iens					             do ie=1,iens
               if(mbrname(ie).eq.'hrrrgsd') then		               if(mbrname(ie).eq.'hrrrgsd') then
                miss(ie)=1					                miss(ie)=1
               end if						               end if
             end do						             end do
          end if						          end if


            if(k4(nv).eq.19.and.k5(nv).eq.0) then  ! Visibili	            if(k4(nv).eq.19.and.k5(nv).eq.0) then  ! Visibili
             do ie =1,iens					             do ie =1,iens
               if(apoint(ie).lt.1.0) miss(ie)=1    !exclude s	               if(apoint(ie).lt.1.0) miss(ie)=1    !exclude s
             end do						             end do
            end if						            end if

            if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.2) t	            if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.2) t
                do i =1,iens					                do i =1,iens
                 if(apoint(i).le.0.) apoint(i)=20000.0		                 if(apoint(i).le.0.) apoint(i)=20000.0
                end do						                end do
            end if						            end if
            if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.3) t	            if(k4(nv).eq.3.and.k5(nv).eq.5.and.k6(nv).eq.3) t
                do i =1,iens					                do i =1,iens
                 if(apoint(i).le.0.) apoint(i)=20000.0		                 if(apoint(i).le.0.) apoint(i)=20000.0
                end do						                end do
            end if						            end if


            if(trim(op(nv)).ne.'-') then			            if(trim(op(nv)).ne.'-') then

             thr1 = Thrs(nv,lt)					             thr1 = Thrs(nv,lt)
             thr2 = 0.						             thr2 = 0.
             call getprob(apoint,iens,thr1,thr2,op(nv),aprob,	             call getprob(apoint,iens,thr1,thr2,op(nv),aprob,
     +                         miss,weight)			     +                         miss,weight)
             vrbl_pr(igrid,lv,lt)=aprob				             vrbl_pr(igrid,lv,lt)=aprob

            else						            else

             if(lt.lt.Tlvl(nv)) then				             if(lt.lt.Tlvl(nv)) then
               thr1 = Thrs(nv,lt)				               thr1 = Thrs(nv,lt)
               thr2 = Thrs(nv,lt+1)				               thr2 = Thrs(nv,lt+1)
               call getprob(apoint,iens,thr1,thr2,op(nv),apro	               call getprob(apoint,iens,thr1,thr2,op(nv),apro
     +                      miss,weight)			     +                      miss,weight)
               vrbl_pr(igrid,lv,lt)=aprob			               vrbl_pr(igrid,lv,lt)=aprob
             end if						             end if

            end if						            end if

           end do						           end do

          if(vname(nv).eq.'AP3h') then    !This var will be u	          if(vname(nv).eq.'AP3h') then    !This var will be u
            if(thr1.eq.0.25) then				            if(thr1.eq.0.25) then
             p03mp01(:)=vrbl_pr(:,lv,lt)			             p03mp01(:)=vrbl_pr(:,lv,lt)
            end if						            end if
          end if						          end if

c        write(*,'(a4,10f9.2)')'PROB',(vrbl_pr(i,lv,lt),i=100	c        write(*,'(a4,10f9.2)')'PROB',(vrbl_pr(i,lv,lt),i=100

          end do !end of Tlvl					          end do !end of Tlvl
         end do !end of Plvl					         end do !end of Plvl


        END IF							        END IF


        write(*,*) 'Ensemble computation done for direct var 	        write(*,*) 'Ensemble computation done for direct var 
c Loop 1-3:  Packing  mean/spread/prob for this direct variab	c Loop 1-3:  Packing  mean/spread/prob for this direct variab

       !ceiling/cloud base/freezing level can not use NAM's g	       !ceiling/cloud base/freezing level can not use NAM's g
       !Other only can use RAP's gfld				       !Other only can use RAP's gfld

							      >	       !On Dell VIS only can use its own gfld 
							      >
       if(k4(nv).eq.3.and.k5(nv).eq.5) then			       if(k4(nv).eq.3.and.k5(nv).eq.5) then
          gfld_temp=gfld_rap				      |	          gfld_temp=gfld_ceil
       else if(k4(nv).eq.19.and.k5(nv).eq.0.and.k6(nv).eq.1) 	       else if(k4(nv).eq.19.and.k5(nv).eq.0.and.k6(nv).eq.1) 
          !gfld_temp=gfld_vis				      |	          gfld_temp=gfld_vis
          gfld_temp=gfld_rap				      <
       else							       else
          gfld_temp=gfld_nam					          gfld_temp=gfld_nam
       end if							       end if

      call packGB2_mean(imean,isprd,vrbl_mn,vrbl_sp,   !jpd12	      call packGB2_mean(imean,isprd,vrbl_mn,vrbl_sp,   !jpd12
     +     nv,jpd1,jpd2,jpd10,jpd27,jf,Lm,			     +     nv,jpd1,jpd2,jpd10,jpd27,jf,Lm,
     +     iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_temp)      	     +     iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_temp)      

         write(*,*) 'packing mean direct var for', nv		         write(*,*) 'packing mean direct var for', nv

      call packGB2_prob(iprob,vrbl_pr,             !jpd12 is 	      call packGB2_prob(iprob,vrbl_pr,             !jpd12 is 
     +     nv,jpd1,jpd2,jpd10,jpd27,jf,Lp,Lth,			     +     nv,jpd1,jpd2,jpd10,jpd27,jf,Lp,Lth,
     +     iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_temp)		     +     iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_temp)

         write(*,*) 'packing prob direct var for', nv		         write(*,*) 'packing prob direct var for', nv

 222    CONTINUE 						 222    CONTINUE 

c Loop 1-4: Deallocation					c Loop 1-4: Deallocation

        deallocate (rawdata_mn)				      |	        if (allocated(rawdata_mn)) deallocate (rawdata_mn)
        deallocate (rawdata_pr)				      |	        if (allocated(rawdata_pr)) deallocate (rawdata_pr)
        deallocate (vrbl_mn)				      |	        if (allocated(vrbl_mn)) deallocate (vrbl_mn)
        deallocate (vrbl_sp)				      |	        if (allocated(vrbl_sp)) deallocate (vrbl_sp)
        deallocate (vrbl_pr)				      |	        if (allocated(vrbl_pr)) deallocate (vrbl_pr)

        write(*,*) 'Variable # ', nv, ' done ....'		        write(*,*) 'Variable # ', nv, ' done ....'
      								      
2001     continue  !end of direct variables loop		2001     continue  !end of direct variables loop



ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Loop 2: for derived variables				c  Loop 2: for derived variables
c    2-0: allocate necessary arrays				c    2-0: allocate necessary arrays
c    2-1: compute all derived variable by calling their corre	c    2-1: compute all derived variable by calling their corre
c            Note: all input data will be read inside each su	c            Note: all input data will be read inside each su
c    2-2: pack derived varaibles				c    2-2: pack derived varaibles
c    2-3: deallocation						c    2-3: deallocation

       write(*,*) 'Now begin to generate derived products ...	       write(*,*) 'Now begin to generate derived products ...

       DO 2002 nv = 1, nderiv					       DO 2002 nv = 1, nderiv

c   Loop 2-0: allocation					c   Loop 2-0: allocation
         gfld%discipline=0   !reset discipline# in case it wa	         gfld%discipline=0   !reset discipline# in case it wa

         jpd1=dk4(nv)						         jpd1=dk4(nv)
         jpd2=dk5(nv)						         jpd2=dk5(nv)
         jpd10=dk6(nv)						         jpd10=dk6(nv)
         jpd27=-9999						         jpd27=-9999

          Lm=max(1,dMlvl(nv))					          Lm=max(1,dMlvl(nv))
          Lp=max(1,dPlvl(nv))					          Lp=max(1,dPlvl(nv))
          Lth=max(1,dTlvl(nv))					          Lth=max(1,dTlvl(nv))
c          write(*,*) 'dTlvl(nv)=',dTlvl(nv),Lth		c          write(*,*) 'dTlvl(nv)=',dTlvl(nv),Lth

          if (.NOT.allocated(derv_mn)) then			          if (.NOT.allocated(derv_mn)) then
            allocate (derv_mn(jf,Lm))         			            allocate (derv_mn(jf,Lm))         
          end if						          end if
          if (.NOT.allocated(derv_sp)) then			          if (.NOT.allocated(derv_sp)) then
            allocate (derv_sp(jf,Lm))				            allocate (derv_sp(jf,Lm))
          end if						          end if
          if (.NOT.allocated(derv_pr)) then			          if (.NOT.allocated(derv_pr)) then
            allocate (derv_pr(jf,Lp,Lth))			            allocate (derv_pr(jf,Lp,Lth))
          end if						          end if

c Loop 2-1: Computation 					c Loop 2-1: Computation 

cc%%%%%%% 1. To  see if there is thickness computation, if ye	cc%%%%%%% 1. To  see if there is thickness computation, if ye
c           if (dk5(nv).eq.7.and. dk6(nv).eq.101) then		c           if (dk5(nv).eq.7.and. dk6(nv).eq.101) then
c								c

cc%%%%%%% 2. To see if there is precipitation type computatio	cc%%%%%%% 2. To see if there is precipitation type computatio
          if (dk4(nv).eq.1.and.dk5(nv).eq.19) then		          if (dk4(nv).eq.1.and.dk5(nv).eq.19) then

              if (.NOT.allocated(ptype_mn)) then		              if (.NOT.allocated(ptype_mn)) then
                allocate (ptype_mn(jf,4))			                allocate (ptype_mn(jf,4))
              end if						              end if
              if (.NOT.allocated(ptype_pr)) then		              if (.NOT.allocated(ptype_pr)) then
                allocate (ptype_pr(jf,4))			                allocate (ptype_pr(jf,4))
              end if						              end if
            							            
              call preciptype (nv,ifunit,jf,iens,		              call preciptype (nv,ifunit,jf,iens,
     +         ptype_mn,ptype_pr)				     +         ptype_mn,ptype_pr)

              do jp=1,4						              do jp=1,4
               jpd1=1						               jpd1=1
               jpd2=jptyp2(jp)					               jpd2=jptyp2(jp)
               jpd10=1						               jpd10=1
               jpd12=0						               jpd12=0
               jpd27=-999					               jpd27=-999
               derv_mn(:,1)=ptype_mn(:,jp)     !for precip ty	               derv_mn(:,1)=ptype_mn(:,jp)     !for precip ty
               derv_sp=0.0					               derv_sp=0.0
               derv_pr(:,1,1)=ptype_pr(:,jp)			               derv_pr(:,1,1)=ptype_pr(:,jp)

               gfld_temp=gfld_nam				               gfld_temp=gfld_nam
               call packGB2_mean_derv(imean,isprd,derv_mn,	               call packGB2_mean_derv(imean,isprd,derv_mn,
     +              derv_sp,nv,jpd1,jpd2,jpd10,jpd27,jf,Lm,	     +              derv_sp,nv,jpd1,jpd2,jpd10,jpd27,jf,Lm,
     +              iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_te	     +              iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_te

               gfld_temp=gfld_nam                           !	               gfld_temp=gfld_nam                           !
               call packGB2_prob_derv(iprob,derv_pr,		               call packGB2_prob_derv(iprob,derv_pr,
     +              nv,jpd1,jpd2,jpd10,jpd27,jf,Lp,Lth,		     +              nv,jpd1,jpd2,jpd10,jpd27,jf,Lp,Lth,
     +              iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_te	     +              iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_te

              end do						              end do

              deallocate (ptype_mn)			      |	              if (allocated(ptype_mn)) deallocate (ptype_mn)
              deallocate (ptype_pr)			      |	              if (allocated(ptype_pr)) deallocate (ptype_pr)

c              write(*,*) 'preciptype done!'			c              write(*,*) 'preciptype done!'
            end if   !end of preciptype computation and save	            end if   !end of preciptype computation and save

cc%%%%%%% 3. To see if there is wind speed computation, if ye	cc%%%%%%% 3. To see if there is wind speed computation, if ye
          if (dk4(nv).eq.2.and.dk5(nv).eq.1.and.dk6(nv).ne.10	          if (dk4(nv).eq.2.and.dk5(nv).eq.1.and.dk6(nv).ne.10
            call wind (nv,ifunit,jf,iens,Lm,Lp,Lth,		            call wind (nv,ifunit,jf,iens,Lm,Lp,Lth,
     +        derv_mn,derv_sp,derv_pr,weight,mbrname)		     +        derv_mn,derv_sp,derv_pr,weight,mbrname)
c            write(*,*) 'Wind done'				c            write(*,*) 'Wind done'
          end if						          end if


cc%%%%%%% 4. To see if there is icing computation, if yes, do	cc%%%%%%% 4. To see if there is icing computation, if yes, do
          if (dk4(nv).eq.19.and.dk5(nv).eq.7) then		          if (dk4(nv).eq.19.and.dk5(nv).eq.7) then
            call get_icing (nv,ifunit,jf,iens,Lp,Lth,		            call get_icing (nv,ifunit,jf,iens,Lp,Lth,
     +              derv_pr,weight)				     +              derv_pr,weight)
c            write(*,*) 'Icing done'				c            write(*,*) 'Icing done'
          end if						          end if

cc%%%%%%% 5. To see if there is CAT computation, if yes, do i	cc%%%%%%% 5. To see if there is CAT computation, if yes, do i
          if (dk4(nv).eq.19.and.dk5(nv).eq.22) then		          if (dk4(nv).eq.19.and.dk5(nv).eq.22) then
            call get_cat (nv,ifunit,jf,iens,Lp,Lth,		            call get_cat (nv,ifunit,jf,iens,Lp,Lth,
     +              derv_pr,im,jm,dx,dy,weight)			     +              derv_pr,im,jm,dx,dy,weight)
            dPlvl(nv)=dPlvl(nv)-1				            dPlvl(nv)=dPlvl(nv)-1
c            write(*,*) 'CAT done' 				c            write(*,*) 'CAT done' 
          end if						          end if

cc%%%%%%% 6. To see if there is flight restriction  computati	cc%%%%%%% 6. To see if there is flight restriction  computati
          if (dk4(nv).eq.19.and.dk5(nv).eq.205) then		          if (dk4(nv).eq.19.and.dk5(nv).eq.205) then
            call  flight_res (nv,ifunit,jf,iens,Lp,Lth,		            call  flight_res (nv,ifunit,jf,iens,Lp,Lth,
     +              derv_pr,weight)				     +              derv_pr,weight)
c             write(*,*) 'Flight restiction done'		c             write(*,*) 'Flight restiction done'
          end if						          end if

cc%%%%%%% 7. To see if there is Hains index for fire weather 	cc%%%%%%% 7. To see if there is Hains index for fire weather 
          if (dk4(nv).eq.4.and.dk5(nv).eq.2) then		          if (dk4(nv).eq.4.and.dk5(nv).eq.2) then
            dTlvl(nv)=dTlvl(nv)-1				            dTlvl(nv)=dTlvl(nv)-1
            Lth=Lth-1                !since dop='-'		            Lth=Lth-1                !since dop='-'
            call fire_weather (nv,ifunit,jf,iens,Lp,Lth,	            call fire_weather (nv,ifunit,jf,iens,Lp,Lth,
     +              derv_pr,weight)				     +              derv_pr,weight)
            							            
            gfld%discipline=2      !Fireweather discipline = 	            gfld%discipline=2      !Fireweather discipline = 
c            write(*,*) 'Hains Index done'			c            write(*,*) 'Hains Index done'
          end if						          end if

cc%%%%%%% 8. To see if there is ceiling computation, if yes, 	cc%%%%%%% 8. To see if there is ceiling computation, if yes, 

          if (dk4(nv).eq.3.and.dk5(nv).eq.5.and.dk6(nv).eq.21	          if (dk4(nv).eq.3.and.dk5(nv).eq.5.and.dk6(nv).eq.21
            call  getceiling (nv,ifunit,jf,iens,Lm,Lp,Lth,	            call  getceiling (nv,ifunit,jf,iens,Lm,Lp,Lth,
     +             derv_mn,derv_sp,derv_pr,weight)		     +             derv_mn,derv_sp,derv_pr,weight)
           							           
c            write(*,*) 'getceiling done', derv_mn(10000,1)	c            write(*,*) 'getceiling done', derv_mn(10000,1)
          end if						          end if


cc%%%%%%% 9. To see if there is fog  computation, if yes, do 	cc%%%%%%% 9. To see if there is fog  computation, if yes, do 

          if(dk4(nv).eq.6.and.dk5(nv).eq.193.and.dk6(nv).eq.1	          if(dk4(nv).eq.6.and.dk5(nv).eq.193.and.dk6(nv).eq.1
     +                             and.itime.ge.2) then		     +                             and.itime.ge.2) then

           call new_fog(nv,ifunit,ipunit,jf,im,jm,dx,dy,inter	           call new_fog(nv,ifunit,ipunit,jf,im,jm,dx,dy,inter
     +             iens,Lm,Lp,Lth,derv_mn,derv_sp,derv_pr,wei	     +             iens,Lm,Lp,Lth,derv_mn,derv_sp,derv_pr,wei
     +             ierr_open_punit)				     +             ierr_open_punit)
c           write(*,*) 'new_fog done'				c           write(*,*) 'new_fog done'

         end if							         end if

cc%%%%%%% 10. To see if there is thickness computation, if ye	cc%%%%%%% 10. To see if there is thickness computation, if ye
          if(dk4(nv).eq.3.and.dk5(nv).eq.5.and.			          if(dk4(nv).eq.3.and.dk5(nv).eq.5.and.
     +                             dk6(nv).eq.101) then		     +                             dk6(nv).eq.101) then

            call thickness (nv,ifunit,jf,iens,Lm,Lp,Lth,	            call thickness (nv,ifunit,jf,iens,Lm,Lp,Lth,
     +             derv_mn,derv_sp,derv_pr,weight)		     +             derv_mn,derv_sp,derv_pr,weight)

c              write(*,*) 'Thickness done'			c              write(*,*) 'Thickness done'
          							          
          end if						          end if


cc%%%%%%% 11. To see if there is LLWS computation, if yes, do	cc%%%%%%% 11. To see if there is LLWS computation, if yes, do
        if(dk4(nv).eq.2.and.dk5(nv).eq.192.and.			        if(dk4(nv).eq.2.and.dk5(nv).eq.192.and.
     +                             dk6(nv).eq.1) then		     +                             dk6(nv).eq.1) then


         !write(*,*) 'call llws ', eps       !??? Can not wri	         !write(*,*) 'call llws ', eps       !??? Can not wri

         call llws (nv,ifunit,jf,iens,Lm,Lp,Lth,eps,		         call llws (nv,ifunit,jf,iens,Lm,Lp,Lth,eps,
     +          derv_mn,derv_sp,derv_pr,weight)			     +          derv_mn,derv_sp,derv_pr,weight)

c         write(*,*) 'LLWS done'				c         write(*,*) 'LLWS done'

        end if							        end if

cc%%%%%%% 11. To see if there is CONVECTION  computation, if 	cc%%%%%%% 11. To see if there is CONVECTION  computation, if 
        if(dk4(nv).eq.1.and.dk5(nv).eq.196.and.			        if(dk4(nv).eq.1.and.dk5(nv).eq.196.and.
     +                             dk6(nv).eq.200) then		     +                             dk6(nv).eq.200) then
         call getconv(nv,ipunit,jf,im,jm,est,iens,Lm,Lp,Lth,	         call getconv(nv,ipunit,jf,im,jm,est,iens,Lm,Lp,Lth,
     +      gribid,derv_pr,weight,ierr_open_punit)		     +      gribid,derv_pr,weight,ierr_open_punit)

c           write(*,'(a9,10f9.2)')'CONV PROB',			c           write(*,'(a9,10f9.2)')'CONV PROB',
c     +           (derv_pr(i,1,1),i=10001,10010)		c     +           (derv_pr(i,1,1),i=10001,10010)
c            write(*,*) 'getconv done' 				c            write(*,*) 'getconv done' 

        end if							        end if


cc%%%%%%% 12. To see if there is Lighning, if yes, do it	cc%%%%%%% 12. To see if there is Lighning, if yes, do it
c         missing() array is not considered, so current NSSE 	c         missing() array is not considered, so current NSSE 
         if(dk4(nv).eq.17.and.dk5(nv).eq.192.and.		         if(dk4(nv).eq.17.and.dk5(nv).eq.192.and.
     +                             dk6(nv).eq.1) then		     +                             dk6(nv).eq.1) then
         call get_cptp_severe(nv,cycle(ihr+1),cfhr,ifunit,p03	         call get_cptp_severe(nv,cycle(ihr+1),cfhr,ifunit,p03
     +       im,jm,km,jf,iens,Lp,Lth,derv_pr,weight,eps)	     +       im,jm,km,jf,iens,Lp,Lth,derv_pr,weight,eps)
c           write(*,*) 'CPTP done '				c           write(*,*) 'CPTP done '
         end if							         end if


cc%%%%%%% 13. To see if there is 850-300mb mean wind, if yes,	cc%%%%%%% 13. To see if there is 850-300mb mean wind, if yes,
         if(dk4(nv).eq.2.and.dk5(nv).eq.1.and.			         if(dk4(nv).eq.2.and.dk5(nv).eq.1.and.
     +                             dk6(nv).eq.108) then		     +                             dk6(nv).eq.108) then

           call meanwind(nv,ifunit,jf,iens,Lm,Lp,Lth,eps,	           call meanwind(nv,ifunit,jf,iens,Lm,Lp,Lth,eps,
     +          derv_pr,weight,mbrname)				     +          derv_pr,weight,mbrname)

c            write(*,*) '850-300mb mean-wind done'		c            write(*,*) '850-300mb mean-wind done'
         end if							         end if




C  Loop 2-2:  Pack Non-precip type dereved mean/spread/prob p	C  Loop 2-2:  Pack Non-precip type dereved mean/spread/prob p
C								C
          if(dk4(nv).eq.1.and.dk5(nv).eq.19 ) then  !Precip t	          if(dk4(nv).eq.1.and.dk5(nv).eq.19 ) then  !Precip t
             goto 20021						             goto 20021
          else                                       !Non-pre	          else                                       !Non-pre
               jpd1=dk4(nv)					               jpd1=dk4(nv)
               jpd2=dk5(nv)					               jpd2=dk5(nv)
               jpd10=dk6(nv)					               jpd10=dk6(nv)
               jpd27=-9999					               jpd27=-9999
               !write(*,*) 'pack _mean_derv for ', nv		               !write(*,*) 'pack _mean_derv for ', nv

               !Ceiling use NAM's gfld, other use RAP's gfld  |	               !Ceiling use RAP's gfld, other use RAP's gfld
               if(dk4(nv).eq.3.and.dk5(nv).eq.5)then		               if(dk4(nv).eq.3.and.dk5(nv).eq.5)then
                gfld_temp=gfld_rap			      |	                gfld_temp=gfld_ceil
               else						               else
                gfld_temp=gfld_nam				                gfld_temp=gfld_nam
               end if						               end if

               write(*,*) 'pack _derv for ', nv			               write(*,*) 'pack _derv for ', nv
     +          ,jpd1,jpd2,jpd10,jpd27,iprob,jf,Lp,Lth,		     +          ,jpd1,jpd2,jpd10,jpd27,iprob,jf,Lp,Lth,
     +          iens,iyr,imon,idy,ihr,ifhr,gribid		     +          iens,iyr,imon,idy,ihr,ifhr,gribid

               call packGB2_prob_derv(iprob,derv_pr,		               call packGB2_prob_derv(iprob,derv_pr,
     +              nv,jpd1,jpd2,jpd10,jpd27,jf,Lp,Lth,		     +              nv,jpd1,jpd2,jpd10,jpd27,jf,Lp,Lth,
     +              iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_na	     +              iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_na

               call packGB2_mean_derv(imean,isprd,derv_mn,	               call packGB2_mean_derv(imean,isprd,derv_mn,
     +              derv_sp,nv,jpd1,jpd2,jpd10,jpd27,jf,Lm,	     +              derv_sp,nv,jpd1,jpd2,jpd10,jpd27,jf,Lm,
     +              iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_te	     +              iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_te

               write(*,*) 'pack _derv done for', nv		               write(*,*) 'pack _derv done for', nv


          end if						          end if
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c Loop 2-3: deallocation					c Loop 2-3: deallocation

20021    continue						20021    continue

        deallocate (derv_mn)				      |	       if (allocated(derv_mn)) deallocate (derv_mn)
        deallocate (derv_sp)				      |	       if (allocated(derv_sp)) deallocate (derv_sp)
        deallocate (derv_pr)				      |	       if (allocated(derv_pr)) deallocate (derv_pr)




2002   CONTINUE  ! end of derived variables loop		2002   CONTINUE  ! end of derived variables loop


ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc	ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 								c 
c Loop 3: Process MXP variables (min,max, 10%,20%, ...90%) 	c Loop 3: Process MXP variables (min,max, 10%,20%, ...90%) 
c 3-0: Allocate array mxp8 					c 3-0: Allocate array mxp8 
c 3-1: Compute each mxp variable 				c 3-1: Compute each mxp variable 
c 3-3: pack all mxp variables					c 3-3: pack all mxp variables
c 3-4: deallocate						c 3-4: deallocate
     								     
c       write(*,*) 'Now begin to generate MXP products ......	c       write(*,*) 'Now begin to generate MXP products ......
       								       
       if(nmxp.gt.0) then					       if(nmxp.gt.0) then
         pmin=trim(eps)//'.pmin.t'//cycle(ihr+1)//'z'//'.f'//	         pmin=trim(eps)//'.pmin.t'//cycle(ihr+1)//'z'//'.f'//
         pmax=trim(eps)//'.pmax.t'//cycle(ihr+1)//'z'//'.f'//	         pmax=trim(eps)//'.pmax.t'//cycle(ihr+1)//'z'//'.f'//
         pmod=trim(eps)//'.pmod.t'//cycle(ihr+1)//'z'//'.f'//	         pmod=trim(eps)//'.pmod.t'//cycle(ihr+1)//'z'//'.f'//
         pp10=trim(eps)//'.pp10.t'//cycle(ihr+1)//'z'//'.f'//	         pp10=trim(eps)//'.pp10.t'//cycle(ihr+1)//'z'//'.f'//
         pp25=trim(eps)//'.pp25.t'//cycle(ihr+1)//'z'//'.f'//	         pp25=trim(eps)//'.pp25.t'//cycle(ihr+1)//'z'//'.f'//
         pp50=trim(eps)//'.pp50.t'//cycle(ihr+1)//'z'//'.f'//	         pp50=trim(eps)//'.pp50.t'//cycle(ihr+1)//'z'//'.f'//
         pp75=trim(eps)//'.pp75.t'//cycle(ihr+1)//'z'//'.f'//	         pp75=trim(eps)//'.pp75.t'//cycle(ihr+1)//'z'//'.f'//
         pp90=trim(eps)//'.pp90.t'//cycle(ihr+1)//'z'//'.f'//	         pp90=trim(eps)//'.pp90.t'//cycle(ihr+1)//'z'//'.f'//

         call baopen(301,pmin,ierr)				         call baopen(301,pmin,ierr)
         call baopen(302,pmax,ierr)				         call baopen(302,pmax,ierr)
         call baopen(303,pmod,ierr)				         call baopen(303,pmod,ierr)
         call baopen(304,pp10,ierr)				         call baopen(304,pp10,ierr)
         call baopen(305,pp25,ierr)				         call baopen(305,pp25,ierr)
         call baopen(306,pp50,ierr)				         call baopen(306,pp50,ierr)
         call baopen(307,pp75,ierr)				         call baopen(307,pp75,ierr)
         call baopen(308,pp90,ierr)				         call baopen(308,pp90,ierr)
       end if							       end if

       DO 2003 nv = 1, nmxp					       DO 2003 nv = 1, nmxp

c  Loop 3-0: allocation 					c  Loop 3-0: allocation 

         Lq=max(1,qMlvl(nv))					         Lq=max(1,qMlvl(nv))
         if (.NOT.allocated(mxp8)) then				         if (.NOT.allocated(mxp8)) then
          allocate (mxp8(jf,Lq,8))				          allocate (mxp8(jf,Lq,8))
         end if							         end if
c Loop 3-1: Computation						c Loop 3-1: Computation
         call get_mxp(nv,ifunit,jf,iens,Lq,mxp8,weight) 	         call get_mxp(nv,ifunit,jf,iens,Lq,mxp8,weight) 
         write(*,*) 'call get_mxp done for ', nv		         write(*,*) 'call get_mxp done for ', nv

c Loop 3-2: Packing 						c Loop 3-2: Packing 

         gfld_temp=gfld_nam					         gfld_temp=gfld_nam

         jpd1=qk4(nv)						         jpd1=qk4(nv)
         jpd2=qk5(nv)						         jpd2=qk5(nv)
         jpd10=qk6(nv)						         jpd10=qk6(nv)
         jpd27=-9999						         jpd27=-9999


         do kq=1,8						         do kq=1,8
          call packGB2_mxp(iqout(kq),kq,mxp8,    		          call packGB2_mxp(iqout(kq),kq,mxp8,    
     +      nv,jpd1,jpd2,jpd10,jpd27,jf,Lq,			     +      nv,jpd1,jpd2,jpd10,jpd27,jf,Lq,
     +      iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_temp)     	     +      iens,iyr,imon,idy,ihr,ifhr,gribid,gfld_temp)     
         end do							         end do


         deallocate(mxp8)				      |	        if (allocated(mxp8)) deallocate(mxp8)
2003  CONTINUE							2003  CONTINUE
       								       

       do irun=1,iens						       do irun=1,iens
        call baclose(ifunit(irun),ierr)				        call baclose(ifunit(irun),ierr)
        call baclose(ipunit(irun),ierr)				        call baclose(ipunit(irun),ierr)
       end do							       end do

       call baclose(imean,ierr)					       call baclose(imean,ierr)
       call baclose(isprd,ierr)					       call baclose(isprd,ierr)
       call baclose(iprob,ierr)					       call baclose(iprob,ierr)

       if (nmxp.gt.0) then					       if (nmxp.gt.0) then
         call baclose(301,ierr)					         call baclose(301,ierr)
         call baclose(302,ierr)					         call baclose(302,ierr)
         call baclose(303,ierr)					         call baclose(303,ierr)
         call baclose(304,ierr)					         call baclose(304,ierr)
         call baclose(305,ierr)					         call baclose(305,ierr)
         call baclose(306,ierr)					         call baclose(306,ierr)
         call baclose(307,ierr)					         call baclose(307,ierr)
         call baclose(308,ierr)					         call baclose(308,ierr)
       end if							       end if
 								 
3000    continue   ! end of itime loop				3000    continue   ! end of itime loop
							      <
      								      
      !call gf_free(gfld) 				      <
      !call gf_free(gfld_temp) 				      <
      !call gf_free(gfld_rap) 				      <
      !call gf_free(gfld_nam) 				      <
      deallocate (fhead)				      <
      deallocate (apoint)				      <
      deallocate (missing)				      <
      deallocate (miss)					      <
      deallocate (p03mp01)				      <

      write(*,*) 'Entire program completed!'			      write(*,*) 'Entire program completed!'

      stop							      stop
      end							      end



